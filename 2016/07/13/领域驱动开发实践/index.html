<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>领域驱动开发实践 | megagao</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近一个多月比较忙，先是和导师一起去香港参加了一次学术会议，然后开始准备期末考试，接着赶了一篇学术论文发表，这几天又把导师安排的项目赶上进度。博客基本没更新。
七月十号去岛内参加了coding和3w举办的一场技术分享会，学到了很多知识，见识了很多大牛。几天分享一下王立老师讲的领域驱动的知识（ppt+速记）。
先做一个自我介绍，我叫王立，曾经在多家上市公司担任架构师和技术经理，包括阿里巴巴，今天很高">
<meta property="og:type" content="article">
<meta property="og:title" content="领域驱动开发实践">
<meta property="og:url" content="http://realfond.cn/2016/07/13/领域驱动开发实践/index.html">
<meta property="og:site_name" content="megagao">
<meta property="og:description" content="最近一个多月比较忙，先是和导师一起去香港参加了一次学术会议，然后开始准备期末考试，接着赶了一篇学术论文发表，这几天又把导师安排的项目赶上进度。博客基本没更新。
七月十号去岛内参加了coding和3w举办的一场技术分享会，学到了很多知识，见识了很多大牛。几天分享一下王立老师讲的领域驱动的知识（ppt+速记）。
先做一个自我介绍，我叫王立，曾经在多家上市公司担任架构师和技术经理，包括阿里巴巴，今天很高">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/1.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/2.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/3.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/4.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/5.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/6.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/7.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/8.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/9.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/10.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/11.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/12.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/13.png">
<meta property="og:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/14.png">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz/SYqxq8d4HWjGeCSkVzAqY7icnW2JfrxhduD3oFI26iaHVeL1ubdTRteib2gfVZ930o50NMYOVoMdmiajIqohyNKj1g/640">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz/SYqxq8d4HWjGeCSkVzAqY7icnW2Jfrxhd8ibawGibcJhDnzC0tTBpdrwY1syC5Pqf5KdsfF4ibibricY0RiaVeqf0h74A/640">
<meta property="og:updated_time" content="2016-09-10T12:03:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="领域驱动开发实践">
<meta name="twitter:description" content="最近一个多月比较忙，先是和导师一起去香港参加了一次学术会议，然后开始准备期末考试，接着赶了一篇学术论文发表，这几天又把导师安排的项目赶上进度。博客基本没更新。
七月十号去岛内参加了coding和3w举办的一场技术分享会，学到了很多知识，见识了很多大牛。几天分享一下王立老师讲的领域驱动的知识（ppt+速记）。
先做一个自我介绍，我叫王立，曾经在多家上市公司担任架构师和技术经理，包括阿里巴巴，今天很高">
<meta name="twitter:image" content="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/1.png">
  
    <link rel="alternative" href="/atom.xml" title="megagao" type="application/atom+xml">
  
  
    <link rel="icon" href="/icon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/icon.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Mega Gao</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
							<li><a href="/tags/项目">项目</a></li>
				        
							<li><a href="/tags/分享">分享</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/megagao" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/2758165673#!/u/2758165673?is_all=1" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:megagao@126.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/分享/" style="font-size: 20px;">分享</a> <a href="/tags/随笔/" style="font-size: 20px;">随笔</a> <a href="/tags/项目/" style="font-size: 10px;">项目</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://dotgeng.github.io/">Dot Geng的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">怕什么真理无穷，进一寸有一寸的欢喜。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Mega Gao</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/icon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Mega Gao</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
					<li><a href="/tags/项目">项目</a></li>
		        
					<li><a href="/tags/分享">分享</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/megagao" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/2758165673#!/u/2758165673?is_all=1" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:megagao@126.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-领域驱动开发实践" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/13/领域驱动开发实践/" class="article-date">
  	<time datetime="2016-07-13T13:36:28.000Z" itemprop="datePublished">2016-07-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      领域驱动开发实践
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分享/">分享</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近一个多月比较忙，先是和导师一起去香港参加了一次学术会议，然后开始准备期末考试，接着赶了一篇学术论文发表，这几天又把导师安排的项目赶上进度。博客基本没更新。</p>
<p>七月十号去岛内参加了coding和3w举办的一场技术分享会，学到了很多知识，见识了很多大牛。几天分享一下王立老师讲的领域驱动的知识（ppt+速记）。</p>
<p>先做一个自我介绍，我叫王立，曾经在多家上市公司担任架构师和技术经理，包括阿里巴巴，今天很高兴能跟大家来分享领域驱动设计。领域驱动设计大家应该都听说过，你们在实际项目当中有用过的吗？能不能举个手？没有。确实说领域驱动开发是很有难度的，领域驱动开发我接触的时间比较早，10年前就接触。今天我把我这段时间从事领域驱动开发的心得跟大家做一个分享。<br> <a id="more"></a></p>
<p>为什么我们要来用领域驱动这个概念来做开发呢？这张图大家很熟，最初用户可能是要做这样的东西，做这样的秋千，而产品经理理解是这样的，而到了设计师是理解层这样，而程序员做成这样的，而外部的商业部门宣传是这样子，而我们测试人员拿到的是这样样子，最后实施的是这个样子，到客户的手里是这个样子的。这就是典型的需求问题。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/1.png" alt=""></p>
<p>为什么会造成这样的问题，其中很重要的一个原因就是沟通不到位。为什么会沟通不到位？Booch曾经说过一句话：科学的一个普遍问题是必须对被观测的对象和情况，建立一种有意义的分类方法，以便人们理解这些观测结果，也有助于科学理论的持续发展。因为我们没有去表达它，去理解他，所以说我们每次信息传递和理解的时候就会出现歧义。</p>
<p>如果我们没有数学表达式的话，很难想象数学领域的发展。正是因为有数学的表达式，才促进了数学的思考和发展，不仅仅是沟通的问题，而是一个理解和发展的问题。那么面对这么复杂的业务，用什么样的表示法去沟通、去理解、去发展？我们没有。所以这个时候就必须要引用一种表示法，这个表示法就是以一种叫做领域语言模型的东西。</p>
<p>界面描述不等于业务需求，因为业务需求涉及内部业务对象的各种状态组合与彼此动态的逻辑关系。你看到的产品界面部分都是冰上露出水面的部分，水下的部分看不见，所以说我们需要一种 UML+业务词典的方式，用这种标准的方式来表述、理解和思考它，这里面包括了流程图、协作图、状态图、活动图等。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/2.png" alt=""></p>
<p>领域模型语言是领域驱动开发的基础，那什么叫领域驱动开发？先看什么是领域，领域就是业务领域，我见过很多伙伴们在分析业务的时候，最常用的就是脑图，从一个问题领域的主题开始然后一层层分解——业务是什么？有哪些概念和关系？有哪些状态与规则？有哪些场景？有哪些流程等等，这些都是领域的问题，只要是同一个问题领域，就存在相似性。比如大家发现银行好象业务都差不多，你研究多了，你就成了银行专家，所以专业领域是很值得探索的。</p>
<p>那为什么我们要做领域建模？业务的表现是各种各样，A银行和B银行的业务看上去是不一样，但是内在的本质是一样的。再比如财务，那个时候最早没有财务这个软件出现的时候，可能大家每一家公司在财务问题上都有自己的一套实现方式，但是最终有一个财务软件出来，说所有的这些问题只要一种模式去解决它，能够通用。那为什么能通用？财务软件解决了一个问题，就是探索到需求背后不变的本质，本质一直都是不变的，而只是外部应用的环境在变，但财务软件始终适用，如果你对本质的理解是错误，就像你把地球理解成平，不是圆的，你也能解释昼夜交替的现象，但是，你就很难解释其它更复杂的天象，同理，对业务本质的提取如果是错的，软件将来就很难满足各种合理的需求变化，这是我们应对需求变更如此痛苦的重要原因之一，我们需要用科学的方法来建模和提取本质，也就是用UML来设计与表达业务领域的概念、关联关系与内在的规律。</p>
<p>我面试过一些开发人员，包括架构师，我问他们怎么思考架构设计？他们说用了 ssh 架构，或者 ssm 架构，其实这种架构跟业务没有关系，每家公司都一样，根本不是一个应用架构特有的价值所在，对一个企业来说，要有竞争力的话，就是要获得那些与业务本质有关的核心资产，使得你可以以最低的成本随需而变，超越你的对手，你的优势就体现在这里，所以，提取本质才是我们的核心。</p>
<p>那什么叫驱动？从领域到领域模型到设计环环相扣，我们始终围绕核心模型进行分析设计，把语言、代码、模型三者紧密绑定（不同于传统分析、设计、实现三个是完全脱节），使得软件既能满足当前的需求，也能支持未来的扩展，让领域模型驱动一切，这就叫驱动。</p>
<p>领域驱动设计主要是包含了三个部分：一个是领域分析，分析你所看到的业务，但是看到的业务不代表内在本质。第二是领域设计，定义业务的内在结构——本质模型。第三是实现，就是把本质模型映射到系统。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/3.png" alt=""></p>
<p>第一步，领域分析，就是要理解领域。这其中我们需要三种人员:开发人员、领域专家和最终用户，首先需要的是领域专家，它对这个领域特别的熟。但是领域专家的思维不像我们程序员这么严谨，所以需要开发人员的参与，而且领域专家的用户体验也不如终端用户那么深刻，所以需要三者的共同配合。</p>
<p>有了这三者的合作，然后我们接下来要去怎么去理解业务，这个时候要有方法，这个方法首先是拆分领域。关于领域拆分很重要的概念叫做 Bounded  CONTEXT，就是限界上下文，比如说商品交易就是一个有界限的应用场景，就是一个限界上下文，还有比如说库存管理也是，财务也是，等等。这都是属于具体的业务环境，也就是界限上下文，同一个用户，你在不同业务环境扮演的角色是不同的，就有了不同的角色命名，同一个事物，在不同的业务场所，业务概念也不尽相同，所以说，先有限界上下文，才有业务对象的概念命名，才有业务词汇的标准统一，你才能够精确的去表达你的业务的概念，然后记录到词典里，这个时候交流才没有歧义。所以上下文是模型有意义的前提。</p>
<p>有了对上下文理解之后，为了更好地理解业务的主次关系，需要对领域进行分类，比如说电子商务的网站称之为是一个大的领域，这个时候商品模块就是一个子领域，并且是核心领域，离开它，其它的领域就没有意义了，会员服务也是一个子领域，身份验证也是一个子领域，这些子领域我们把它称作为支撑领域，再有：身份验证，是通用子领域，因为所有子领域都会依赖和使用到它，所以叫做通用子领域。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/4.png" alt=""></p>
<p>做完顶层的分析，其实是业务架构分析，接下来就是领域设计，领域设计是最有艺术的部分，也就是提炼具体的领域概念和相关关系，这里有些概念需要先认识一下。先看“实体”，大家以前做过数据库的建模，建立 E-R 图，每个表通过 ORM 工具映射为实体类，也就是 PO，领域模型中的实体很类似这个 PO，不过 PO 只有数据没有行为，而领域模型的实体是有行为的，所以有所区别。再就是“值对象”，实体和值对象最大的区别在于实体是通过 ID 作为标志，而“值对象”只要内容一样，就完全是同一个东西，比如我叫王立，另外一个人也叫王立，但是我们的身份证不一样，不是同一个人，这叫“实体”，但是一个地址，只要内容一样，就是唯一的，这叫做“值对象”，因此值对象不需要id，实体才需要。实体都有生命周期，如果一个实体的销毁，会导致另外一个实体也被销毁掉，他们的生命周期是捆绑在一起的，那就可以被当作一个聚合，聚合根指的是，这个聚合的生命周期的主导者，它死了，其它实体都没有存在的意义，无论是实体还是聚合根，他们都是有行为的，并且，他们也都是有状态的，状态就是属性。还有一种类型的业务模型，叫领域服务，用于协调那些对象与对象之间的交互的，它只有行为没有状态，也就是没有属性，但是，又可以独立于应用场景，被多个场景复用，这是它区别于应用层服务的地方，应用层服务和场景有关，也就是和用例是一一映射的，领域服务不是，它更具有独立性，可以被应用层服务进行装配使用。</p>
<p>这张图是概念关系图：工厂创建领域对象，领域服务用于协调那些对象与对象之间的交互的，接下去就是聚合根，聚合根包含了下面的实体，包含了值对象，领域服务关注的是群体的行为，使得多个对象进行交互。而聚合根关注的是个体的行为。这些对象被持久化的时候，要通过仓储进行存储。这张图，我们把这些分类都以标签的形式标注在业务对象上。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/5.png" alt=""></p>
<p>这些业务对象是如何被抽取出来的呢？我们是从业务场景入手的，逐步去理解交互的过程，逐步找出这些概念。再对它们的关系进行梳理，例如：这个是订单和订单项，他们之间的关系是一对多的关系，等等。接下来，就是去定义聚合根。比如说订单有一些订单项，他们的生命周期是从属的关系，订单没有了，订单项也就没有了。所以订单是聚合根。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/6.png" alt=""></p>
<p>这里需要注意的是，聚合不等于大对象，相反聚合要尽量设计得小，后面我们会讲到，我们是以聚合为单位整个地加载对象进行操作的，聚合很大的话，内存消耗很大，会导致性能上的问题，另外逻辑控制也会比较复杂。由于聚合是用来捆绑需要维持一致性状态的对象，而不是简单的将对象捆在一起，所以，如果它们内部没有需要维持一致性的规则，就可以让这个内部实体独立为聚合根，使得聚合的结构尽可能小，还有一点要注意，对于子对象的集合很大的情况，聚合根不应该一次性加载它们，而应该使用查询方法按需加载。</p>
<p>聚合之间的关联是通过ID，而不是对象引用。为什么是这样？大家都知道在我们这些对象拉进内存里面以后，这些对象与对象之间会形成一个网状的结构，如果这个网状结构无限的蔓延，就会造成我们的性能损耗非常的厉害。事实上一些数据或者是对象是可以延迟加载的，我们不需要一次性拿出这么多的对象出来，但是后面会讲到，领域对象不是 PO，没办法直接被 ORM 进行管理和延迟加载，所以，为了确保不会立刻加载，我们采用 ID 来建立聚合根之间的关联，在需要的时候，通过引用另一个聚合根的仓储去获取它。</p>
<p>聚合根之间传递的是数据副本，而不能直接传递内部对象的引用，以确保一致性封装的有效性。如果内部对象能够被引用到外部去，实际上就已经破坏了聚合根的封装能力，因为外部对象拿到聚合内部的对象地址引用，是可以直接操作该对象的内容的。因此，聚合与聚合之间是通过接口进行交互，彼此之间只能够传递数据的副本，而不是对象的引用。这样使得聚合和聚合之间是隔离的，每个聚合以后甚至可以放在独立的容器中，扩展为微服务，当然，微服务的粒度要适当控制。</p>
<p>由于聚合之间彼此独立，所以聚合内可以要求强一致性，聚合之间只要最终一致性就可以了，这使得聚合的关系可以是分布式的，可以独立进行细粒度的性能扩容，增强了系统的延展能力。</p>
<p>领域驱动的一个重要的原则就是采用信息专家的原则，把数据对象和操作是捆绑在一起的，我们以前采用传统的做法就是会把数据丢给很多的服务去处理。这里面带来一个问题，就是说由于数据和他的业务逻辑是分离的，分离了以后，这个数据会在各种服务的逻辑碎片中被修改，而这些逻辑碎片的一致性是没有一个地方进行统一维护的，这种碎片化的逻辑在事务脚本化的系统中比比皆是，所以，你会发现系统很难维护，尤其是复杂的业务系统，现在，数据一致性相关的逻辑操作都在聚合体内封装和维护的话，那么这个数据就比较健壮了，这实际上是一种保护性的编程。</p>
<p>我们总结一下领域设计的步骤：划分好边界上下文，发现哪些是应用层，哪些是领域层，在每个边界上下文中设计领域模型，核心是找出聚合根，画出领域模型图，划分每个模型的聚合边界。再结合应用层功能，思考领域模型是如何在业务中经的发挥的作用，最后是场景走查和重构。</p>
<p>当我们把领域模型建立起来之后，需要把它隔离到领域层。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/7.png" alt=""></p>
<p>看这里（左一），这是用户接口层，它只是操作数据的输入输出，不带有任何的业务逻辑，他们之间传递的数据也都是纯粹的数据传输对象。应用层（左二）是跟场景有关的，和用例一一对应。服务层（左三）是可复用的事务脚本，和场景无关，它是无状态的，负责操作调配领域层对象，领域层（右二）封装了和状态有关的领域对象，它是最稳定的核心。大家从学校毕业出来，在学校里你学的知识或能力，无论哪一个岗位上，这些知识能力都不变，变化的只是你使用知识或能力的方式，知识能力的意义就等同于领域层的意义，它封装了稳定的概念与规则，而工作岗位有关的，经常变化的部分等同于用例或服务层，它封装了场景对领域层的装配和使用方式。</p>
<p>接下来是仓储（右一），负责怎么去存取领域对象，以前有人经常问我，领域对象的结构和数据表的结构看起来很像，我为什么还要去建立领域模型，直接建立 E-R 图不就好了？究竟有什么差别？在某一些情况之下，确实很像，但多数时候，领域模型是对象在内存中的结构关系，而且不仅是数据结构，更是行为结构关系，为了优化行为的高内聚低耦合，这种内存结构可能会被拆得很细，还会用到继承、多态，你想，这种结构如果直接映射为数据存储结构，会带来多大的性能问题？甚至是不可实现的，数据存储的时候首先想到的是性能的问题，这个目标与对象行为的解耦合设计目标多数情况是阻抗不匹配的，这种矛盾必须被隔离在不同的层，也就是隔离到领域层和 DAO层，通过仓储层对它们进行结构转化，这就是仓储的意义所在。</p>
<p>如果我们要把数据和逻辑行为绑定，就一定会用到富血模型的编程模式，富血模型是相对于贫血模型而言的，贫血模型指的是领域模型只有数据和 get/Set 方法，业务逻辑操作转移到外部，和数据分离，这其实是大多数我所见到的开发人员的代码风格，而富血模型根本上是采用了信息专家原则——让拥有数据的专家对象拥有操作这些数据的权力，使得无论是聚合根还是其内部对象都获得了封装一致性逻辑的能力，这种对象自治是一种保护性编程，使得代码更加的内聚和模块化，提升代码的健壮性。</p>
<p>如果采用贫血模型，所有的逻辑都被放在事务脚本中执行，就需要把事务脚本拆分到多个细粒度的事务脚本中来完成模块化——无论是拆分方法还是拆分服务对象，否则，这个事务脚本就会变得很臃肿，但是，如果所有细粒度对象自然而然地把属于自身逻辑的操作都纳入自己内部，就避免产生大量额外的细粒度事务脚本，使得高层的服务自然地变得简洁优雅。</p>
<p>再有，事务脚本之所以复杂，是因为有着太多的逻辑判断，这些需要进行逻辑判断的数据代表着不同的状态，现在，富血模型把状态数据和操作逻辑封装在一起，而且，它们还被封装为相同接口下的不同实现，对于同一个接口的不同实现的调用，还需要判断吗？你只要利用多态，自动调用不同的实现就可以操作不同的数据了吧？而且，这些被封装的数据的一致性还更有保障，这就是领域对象采用富血模型的好处。</p>
<p>由于领域对象是富血模型，需要在构造期依赖注入其他对象才能支持一些操作，但是，如果要对领域对象进行缓存，缓存的反序列化操作难以恢复依赖注入，所以，必须在仓储中转化为 POJO 形式的 PO 后进行缓存，这就解释了前面提到的问题，为什么不能直接使用 ORM 对领域对象进行管理和延迟加载，因为如果 ORM 操作的是富血模型的领域对象（例如 mybais 就可以做到），就无法同时再把它转化一次变为可以缓存的 POJO 形式的 PO。</p>
<p>既然聚合是不可拆分的一致性逻辑封装体，那么，仓储就必须以聚合为单位完整地加载整个聚合，应该避免单独加载被肢解的聚合数据，否则，就失去了聚合的完整性意义。</p>
<p>仓储接口的调用接口应当归属领域层，而实现放在仓储层，这种设计，叫做依赖倒置，什么叫“依赖倒置”？这个原则认为：接口的调用方依赖接口，但是他并不关心接口是如何实现的，所以，接口的定义就相当于是调用方提出的“需求”定义（不关心怎么被实现），既然需求的提出者就是需求的拥有着，那么接口的提出者就是接口的拥有者——领域层，所以，接口就应该和领域层在一起，依赖倒置的基本理念是：系统应该从不稳定的模块向稳定的模块依赖，而不是相反，现在，由于接口归属到了稳定的领域层，接口的实现——也就是不稳定的仓储层（可以随时改变实现方式），就反向依赖了稳定的领域层的接口，这就满足了依赖倒置的理念。</p>
<p>DDD 实现还有一个问题，大家知道聚合根是非常结构化的东西，这个结构化的东西带来的一个负面的影响：大家查询的需求是非常灵活的，但聚合根的结构是固定的，如果走聚合根，你要对获取的聚合内的结构化数据进行二次的非结构化过滤和转换，这就是不必要的复杂性。那我们为什么需要聚合根？聚合根的意义在于一致性逻辑的封装，其实只有在写入时才需要这种一致性保护，而不是读的时候。因此，聚合根只跟写有关，那读就完全没有必要用聚合根，所以应该绕过聚合根。因此就提出一个概念，就是我们数据的读和取要从两条路径走。这就叫做 CQRS。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/8.png" alt=""></p>
<p>从前面的这些分析就会发现，由于依赖倒置，领域驱动开发的架构实际上已经从传统的层级的架构转变成为洋葱式的架构。领域核心，不会因为场景变化而变化，是被依赖，所以处于中间。第二层就是服务，封装与场景无关的可复用的调用，第三层是应用——和场景或用例对应，再外是输入输出层，显然，用户接口和数据库存储都是输入输出相关的，并且由于依赖倒置，让数据库从外部依赖内部核心，不再是被依赖的底层，这就是洋葱式架构。</p>
<p>下面我们看一个案例。这个商城从业务上来说拆分为这么几个大块，每个部分都是商城这个大领域当中的子域：结算、会员、访问控制、交易库存、财务。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/9.png" alt=""></p>
<p>其中交易是整个系统存在的核心价值，如果没有交易，那么其他任何的业务其实都是没有意义的。所以说交易是核心的，叫做核心子域。而库存是为交易做支持的，所以它是一个支持域。而会员其实不论是哪一个部分都会用到，因此说这个子域也有一个专有的名词叫做通用子域。访问控制又是另外一种类似的子域，叫做协作子域，财务同样也是一个支持子域，这里面实际上已经进行了架构的切割。架构设计的时候我们要尽量避免模块与模块之间或者系统与系统之间产生依赖的回路。</p>
<p>当把这些子域开始切开以后，接下去我们开始细化。我们来看交易子域。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/10.png" alt=""></p>
<p>作为买家可以干这些事，卖家可以干这些事，了解流程的时候，我会想到他有哪些概念存在。比如说，买家、卖家肯定有的。你可能会问买家和卖家不应该在会员模块里面定义和管理？这就是一个上下文划分的问题，在交易这个上下文才会存在买家和卖家，如果离开交易哪来买家和卖家。所以买家和卖家是在交易上下文当中才存在的，因此领域的概念是在上下文当中存在才有意义的。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/11.png" alt=""></p>
<p>所以首先要把上下文明确出来。买家需要做一些跟商品有关的操作，商品要做上架等。这里面还有货物、SKU 其实不在交易上下文当中，透明的部分统统都会被隔离到其他的上下文当中，比如说货物是库存的上下文。而出帐单、入帐单是在财务那边，当你把上下文切开来以后，会发现这样的分析结果会使得我们可以很单纯的处理跟这个上下文有关的东西。商品包含很多的 SKU，又分很多类型，这些都是值对象，因为它的唯一性通过内容就可以来表示，不需要通过 ID。订单又有订单条目以及订单的当前状态以及历史状态的追踪，还有订单的评价，买家卖家的评价。这些东西都是因为订单的存在而存在。在分析的过程当中我们就会想聚合根是什么？</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/12.png" alt=""></p>
<p>红色圈起来的部分表示他们是一个聚合，因聚合根的生死而生死，我一旦要对聚合进行操作的时候，我会考虑把整个聚合所有的东西一次性载入到内存里，一致性的逻辑都封装在里面，健壮性就有保证。</p>
<p>通过这种方式，每个聚合都相对独立了，于是，我们可以以聚合为单位进行工作分解，大家可以很独立地进行开发——这完全不同于过去那种按功能模块进行分割的开发模式，因为不同功能内部可能会共享一个聚合，那种分工方式必然会把同一个聚合打散，导致逻辑可能的重复和不一致，这就是为什么软件会越做越烂的原因之一，它有一个声名狼藉的名称，叫做烟囱式任务分解！就因为早期懒得做聚合的分析设计，以为很省事，可以“快速开发”，结果，欠下了大量技术的债务——出来混，你迟早要还的，而且还是高利贷，记住！</p>
<p>那么聚合与聚合根之间是什么关系。聚合内的成员只可以引用外部聚合根，而且还仅仅是通过 ID 引用，并间接地从聚合根获取它内部数据的副本，或者把自己的数据副本传递给他，比如说 sku 是商品聚合里面的成员，订单项会用到 sku，但不会去跟 sku 直接产生关系，只会通过商品来获取 sku 的拷贝。这使得说聚合根与聚合根之间是绝缘的，它们内部的一致性完全是被聚合根给封装起来了。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/13.png" alt=""></p>
<p>大家看，这里面每个目录是不是就对应到我们在前面这张图当中的业务模型。实际上可以理解成代码模块就是业务对象，代码的结构跟业务的结构竟然是一样的。因为你不需要进行转化，二者是同构的，使得你看代码结构就能直观地看懂了业务结构，多爽！由于他们之间没有转化，业务怎么变，内部代码就怎么变，这种应对业务变更的成本是最小的，我们的系统的可维护性就很强。</p>
<p><img src="https://coding.net/u/megagao/p/ziyuan/git/raw/master/dddimg/14.png" alt=""></p>
<p>那么怎么实现富血模型？在 Spring 当中有一种注解，叫做“Configurable”，具体用法大家可以去查文档，这使得我们手工 new 一个对象的时候，它也会自动成为容器管理的对象，被依赖注入需要用到的其它对象，于是，它就可以拥有服务对象一样的能力，例如注入了仓储接口，就可以通过其它聚合根id存取其它聚合根的数据。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/SYqxq8d4HWjGeCSkVzAqY7icnW2JfrxhduD3oFI26iaHVeL1ubdTRteib2gfVZ930o50NMYOVoMdmiajIqohyNKj1g/640" alt=""></p>
<p>再来看服务层的时候，大家有没有觉得这个代码非常的简单？很简单。我们把这么多的细节代码都已经拆解到那些细粒度领域对象里面去，所以高层的代码就很简洁。</p>
<p>我们还用到了 Unit Of Work 模式，在对领域模型进行集合操作时，我们可以把需要更新或删除的对象状态标志好，提交给仓储，仓储就会根据状态决定更新还是删除，这就使得领域层不用关心存储的细节。</p>
<p>再来看缓存：仓储的缓存必须要放到 DAO 里面做，因为仓储操作的是领域对象，而领域对象如果被缓存，是无法恢复依赖注入的服务对象的，所以说缓存必须要往下沉淀，放到 DAO 里面对 PO 进行操作。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/SYqxq8d4HWjGeCSkVzAqY7icnW2Jfrxhd8ibawGibcJhDnzC0tTBpdrwY1syC5Pqf5KdsfF4ibibricY0RiaVeqf0h74A/640" alt=""></p>
<p>这是关于 DDD 的其他的主题，实际上我们今天讲到的东西还只是领域对象整个开发的一个简单介绍。其实最有价值的四色原型分析法，有了四色原型分析法我们会提取到一些很有价值的东西，这些很有价值的东西又把它沉淀下来，成为分析模式。一个银行系统之所以在多个银行可以被公用，因为有很多通用的分析模式。还有柔性设计技巧，还有如何精炼模型，识别核心模型以及通用子另，还有DCI架构。</p>
<p>今天我跟大家分享的东西基本上到这里，如果大家有兴趣的话，我非常欢迎和我们一起去探讨。谢谢大家！</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/04/18/单例的五种写法/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          单例的五种写法
        
      </div>
    </a>
  
  
    <a href="/2016/06/26/JVM类加载机制（2）/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">JVM类加载机制（2）</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="领域驱动开发实践" data-title="领域驱动开发实践" data-url="http://realfond.cn/2016/07/13/领域驱动开发实践/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"megagao"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 Mega Gao
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
  </div>
</body>
</html>